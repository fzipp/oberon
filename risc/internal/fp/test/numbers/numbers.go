// Copyright 2021 Frederik Zipp and others; see NOTICE file.
// Use of this source code is governed by the ISC license that
// can be found in the LICENSE file.

// Command numbers generates a Go file containing a slice of uint32 numbers
// as test input for the Oberon RISC emulator's floating-point arithmetic
// operations.
package main

import (
	"flag"
	"fmt"
	"math/rand"
	"os"
)

func usage() {
	fail(`Generates a Go file containing a slice of uint32 numbers as test
input for the Oberon RISC emulator's floating-point arithmetic operations.

Usage:
    numbers [-o go_file] [-n count]

Flags:
    -o   The output file (Go). Default: standard output
    -n   The length of the generated slice of numbers. Default: 25000`)
}

func main() {
	nFlag := flag.Int("n", 25000, "`count`")
	oFlag := flag.String("o", "", "output `file` (Go)")
	flag.Usage = usage
	flag.Parse()

	var err error
	count := *nFlag

	w := os.Stdout
	if *oFlag != "" {
		w, err = os.Create(*oFlag)
		check(err)
	}

	var numbers []uint32
	for e := uint32(0); e < 256; e++ {
		numbers = append(numbers, (e<<23)|0)
		numbers = append(numbers, (e<<23)|1)
		numbers = append(numbers, (e<<23)|0x7fffff)
		numbers = append(numbers, (e<<23)|0x7ffffe)
	}
	for _, x := range numbers {
		numbers = append(numbers, x|0x80000000)
	}
	restCount := count - len(numbers)
	for x := 0; x < restCount; x++ {
		numbers = append(numbers, rand.Uint32())
	}

	_, err = fmt.Fprint(w, `// Code generated by numbers.go; DO NOT EDIT.

package test

var Numbers = []uint32{
`)
	check(err)
	for _, x := range numbers {
		_, err = fmt.Fprintf(w, "\t0x%08X,\n", x)
		check(err)
	}
	_, err = fmt.Fprintln(w, "}")
	check(err)
}

func check(err error) {
	if err != nil {
		fail(err)
	}
}

func fail(msg any) {
	_, _ = fmt.Fprintln(os.Stderr, msg)
	os.Exit(1)
}
